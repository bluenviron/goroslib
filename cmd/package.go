package cmd

import (
	"os"
	"path"
	"path/filepath"
	"strings"
	"text/template"
)

var tplPackage = template.Must(template.New("").Parse(
	`// Package {{ .PkgName }} contains message definitions.
//
//autogenerated:yes
//nolint:revive
package {{ .PkgName }}
`))

// ImportDir generates Go files for all ROS definitions under the directory.
func ImportDir(name string, rosDir string, goDir string) error {
	os.Mkdir(goDir, 0o755)
	err := writeTemplate(filepath.Join(goDir, "package.go"), tplPackage,
		map[string]interface{}{"PkgName": name})
	if err != nil {
		return err
	}

	return filepath.Walk(rosDir, func(filePath string, info os.FileInfo, err error) error {
		if err != nil {
			return err
		}

		switch path.Ext(info.Name()) {
		case ".msg":
			outpath := strings.ToLower(filepath.Join(goDir, "Msg"+strings.TrimSuffix(info.Name(), ".msg")+".go"))
			f, err := os.Create(outpath)
			if err != nil {
				return err
			}
			defer f.Close()
			if err := ImportMsg(filePath, name, name, f); err != nil {
				os.Remove(outpath)
				return err
			}

		case ".srv":
			outpath := strings.ToLower(filepath.Join(goDir, "Srv"+strings.TrimSuffix(info.Name(), ".srv")+".go"))
			f, err := os.Create(outpath)
			if err != nil {
				return err
			}
			defer f.Close()
			if err := ImportSrv(filePath, name, name, f); err != nil {
				os.Remove(outpath)
				return err
			}

		case ".action":
			outpath := strings.ToLower(filepath.Join(goDir, "Action"+strings.TrimSuffix(info.Name(), ".action")+".go"))
			f, err := os.Create(outpath)
			if err != nil {
				return err
			}
			defer f.Close()
			if err := ImportAction(filePath, name, name, f); err != nil {
				os.Remove(outpath)
				return err
			}
		}

		return nil
	})
}

// ImportPackage generates Go files for all ROS definitions under the directory if it's a ROS package.
func ImportPackage(prefix string, dir string, goDir string) error {
	// find folders which contain a "msg", "srv" or "action" subfolder
	paths := make(map[string]struct{})
	err := filepath.Walk(dir, func(path string, info os.FileInfo, err error) error {
		if err != nil {
			return err
		}
		if info.IsDir() &&
			(info.Name() == "msg" || info.Name() == "srv" || info.Name() == "action") {
			paths[filepath.Dir(path)] = struct{}{}
			return nil
		}
		return nil
	})
	if err != nil {
		return err
	}
	for path := range paths {
		name := filepath.Base(filepath.Join(prefix, path[len(dir):]))
		err := ImportDir(name, path, filepath.Join(goDir, name))
		if err != nil {
			return err
		}
	}
	return nil
}

func writeTemplate(fpath string, tpl *template.Template, args map[string]interface{}) error {
	f, err := os.Create(fpath)
	if err != nil {
		return err
	}
	defer f.Close()

	return tpl.Execute(f, args)
}
