package main

import (
	"fmt"
	"io/ioutil"
	"net/url"
	"os"
	"os/exec"
	"path/filepath"
	"strings"
	"text/template"

	"github.com/go-git/go-git/v5"
)

var tplPackage = template.Must(template.New("").Parse(
	`// Package {{ .PkgName }} contains message definitions (autogenerated).
//nolint:golint
package {{ .PkgName }}
`))

var tplTest = template.Must(template.New("").Parse(
	`//nolint:golint
package {{ .PkgName }}

import (
	"testing"
)

func TestCompileOk(t *testing.T) {
}
`))

func shellCommand(cmdstr string) error {
	fmt.Fprintf(os.Stderr, "%s\n", cmdstr)
	cmd := exec.Command("sh", "-c", cmdstr)
	cmd.Stderr = os.Stderr
	cmd.Stdout = os.Stdout
	return cmd.Run()
}

func processDir(name string, dir string) error {
	fmt.Fprintf(os.Stderr, "[%s]\n", name)

	os.Mkdir(filepath.Join("pkg", "msgs", name), 0755)

	err := func() error {
		f, err := os.Create(filepath.Join("pkg", "msgs", name, "package.go"))
		if err != nil {
			return err
		}
		defer f.Close()

		return tplPackage.Execute(f, map[string]interface{}{
			"PkgName": name,
		})
	}()
	if err != nil {
		return err
	}

	err = func() error {
		f, err := os.Create(filepath.Join("pkg", "msgs", name, "package_test.go"))
		if err != nil {
			return err
		}
		defer f.Close()

		return tplTest.Execute(f, map[string]interface{}{
			"PkgName": name,
		})
	}()
	if err != nil {
		return err
	}

	err = filepath.Walk(dir, func(path string, info os.FileInfo, err error) error {
		if err != nil {
			return err
		}

		if strings.HasSuffix(info.Name(), ".msg") {
			outpath := strings.ToLower(filepath.Join("pkg", "msgs", name, "Msg"+strings.TrimSuffix(info.Name(), ".msg")+".go"))
			err = shellCommand(fmt.Sprintf("go run ./cmd/msg-import --gopackage=%s --rospackage=%s %s > %s",
				name,
				name,
				path,
				outpath))
			if err != nil {
				os.Remove(outpath)
				return err
			}

		} else if strings.HasSuffix(info.Name(), ".srv") {
			outpath := strings.ToLower(filepath.Join("pkg", "msgs", name, "Srv"+strings.TrimSuffix(info.Name(), ".srv")+".go"))
			err = shellCommand(fmt.Sprintf("go run ./cmd/srv-import --gopackage=%s --rospackage=%s %s > %s",
				name,
				name,
				path,
				outpath))
			if err != nil {
				os.Remove(outpath)
				return err
			}
		}

		return nil
	})
	if err != nil {
		return err
	}

	return nil
}

func processRepo(repo string) error {
	dir, err := ioutil.TempDir("", "goroslib")
	if err != nil {
		return err
	}
	defer os.RemoveAll(dir)

	_, err = git.PlainClone(dir, false, &git.CloneOptions{
		URL:   repo,
		Depth: 1,
	})
	if err != nil {
		return err
	}

	// find folders which contain a "msg" or "srv" subfolder
	paths := make(map[string]struct{})
	err = filepath.Walk(dir, func(path string, info os.FileInfo, err error) error {
		if err != nil {
			return err
		}

		if info.IsDir() &&
			(info.Name() == "msg" || info.Name() == "srv") {
			paths[filepath.Dir(path)] = struct{}{}
			return nil
		}

		return nil
	})
	if err != nil {
		return err
	}

	u, _ := url.Parse(repo)

	for path := range paths {
		err := processDir(filepath.Base(filepath.Join(u.Path, path[len(dir):])), path)
		if err != nil {
			return err
		}
	}

	return nil
}

func run() error {
	err := shellCommand("rm -rf pkg/msgs/*/")
	if err != nil {
		return err
	}

	done := make(chan error)
	count := 0

	for _, repo := range []string{
		"https://github.com/ros/std_msgs",
		"https://github.com/ros/ros_comm_msgs",
		"https://github.com/ros/common_msgs",
		"https://github.com/ros-drivers/ackermann_msgs",
		"https://github.com/ros-drivers/audio_common",
		"https://github.com/ros-drivers/velodyne",
		"https://github.com/ros-controls/control_msgs",
		"https://github.com/ros-perception/vision_msgs",
	} {
		count++
		go func(repo string) {
			done <- processRepo(repo)
		}(repo)
	}

	for i := 0; i < count; i++ {
		err := <-done
		if err != nil {
			return err
		}
	}

	return nil
}

func main() {
	err := run()
	if err != nil {
		fmt.Fprintf(os.Stderr, "ERR: %s\n", err)
		os.Exit(1)
	}
}
